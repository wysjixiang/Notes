# 操作系统学习笔记、



### 1.导论

1. SMP：对称多处理器 Symmetric MultiProcessor. 所有处理器共享内部物理资源，如总线、内存等

2. 高速缓存一致性，通常是硬件来处理的！

3. Linux内核所用的数据结构有源码可学习：

   <linux/list.h>链表数据结构；

   kfifo.c包含队列实现，linux的队列称为kfifo；

   <linux/rbtree>通过红黑树提供平衡二分查找树的实现

4. 嵌入式系统几乎总是采用实时操作系统，当处理器执行或数据流动具有严格的时间要求时，不二之选
5. GNU通用公共许可证 GNU General Public License, GPL，是著佐权的条文



### 2. 操作系统结构

1. 用户与操作系统的界面有多种方式，其中一种就是提供命令行界面或命令解释程序，允许用户直接输入命令以供操作系统执行。例如shell，就是一个解释程序。在类UNIX系统下，命令解释程序不需要理解指令，而只要通过命令确定一个文件，以加载到内存并执行。例如 rm fuke txt这个命令，会查找名为rm的文件，并用后续参数执行！
2. 系统调用提供操作系统服务接口，在编译时，由编译器直接提供函数库来提供系统调用接口，以链接到操作系统的系统调用
3. 系统调用大致可分为6大类：进程控制、文件管理、设备管理、信息维护、通信和保护
4. 进程间通信的常用模型哟有两个：消息传递模型和共享内存模型
5. 后台服务： 所有通用系统都由方法，以便在引导时创建一些系统程序的进程。这些进程中有的执行完任务后就终止，有的会一直运行到系统停机。一直运行的系统进程，成为服务、子系统或者守护进程。比如一个监听网络连接请求的服务。
6. 加载内核以启动计算机的过程，称为引导。当CPU收到一个重置事件时，例如上电开机或重启，指令寄存器就会加载某个预先定义的内存位置，并从该位置开始执行，该位置就是初始引导程序所在。该程序为只读存储器形式，因为系统启动时RAM处于未知状态。
7. 引导程序可以完成一系列任务，如初始状态诊断、初始化系统等，最终他会启动操作系统。一般引导程序存放再固件上，如EEPROM，而操作系统存放在磁盘、固态等上，在启动时，引导程序会把操作系统先搬运到RAM中再运行

 

### 3. 进程

1. #### 什么时进程？结合线程来说明他们的概念，相同点，不同点。。。！！ 

2. 进程本身也可以作为一个环境，用于执行其他代码，典型的就是JAVA编程环境

3. 操作系统内的每个进程表示，可以采用进程控制快(Process Control Block, PCB)来表示，也称为任务控制快

4. 大多数操作系统对进程的识别采用的是唯一的进程标识符（process identifier，pid），通常是一个整数值

5. 进程init的pid总是1,作为所有用户进程的根进程或父进程

6. 如果一个进程终止，那么它的所有子进程也终止，这种现象，称为级联终止

7. 僵尸进程：当一个进程终止时，操作系统会释放资源，但是他位于进程表中的条目还是在的，直到他的父进程调用wait()。当进程终止但是父进程尚未调用wait，这样的进程就是僵尸进程

8. 如果父进程没有调用wait()就终止，子进程就成了孤儿进程。在linux中，就会将init进程作为孤儿进程的父进程，init会定期调用wait

9. 进程之间可以是独立的也可以是协作的。如果一个进程不影响其他进程或受其他进程影响，那么他就是独立的，否则就是协作的

10. 进程间通信，IPC（InterProcess Communication）

11. #### 共享内存系统

    1. 进程间通信有两种模型，一个是共享内存，另一个是消息传递。消息传递一般通过系统调用来实现
    2. 在共享内存模型中，数据的类型或位置不受操作系统控制，而是由进程决定，另外进程需要确保他们不会向同一个位置同时写入数据
    3. 生产者—消费者问题，这是协作进程的通用范例。生产者进程生成信息，以供消费者进程消费。为了两者并发执行，应有一个可用的缓冲区，生产者和消费者必须同步，避免消费未生产出来的数据
    4. 缓冲区类型可以分为无界缓冲区和有界缓冲区。无界缓冲区生产者可以一直产生新项，而消费者可能需要等待；而对于有界而言，可能两者都需要等待

12. #### 消息传递系统

    1. 直接通信的缺点就是更改进程表示符后需要修改其他所有进程的相关通信定义，所有旧标识符都要被找到并修改为新的
    2. 间接通信解决这一问题，采用邮箱或端口来发送和接受消息。只有两个进程共享一个邮箱时，才能建立通信链路
    3. 阻塞、非阻塞，即同步、异步问题。

13. #### 管道

    1. 管道允许两个进程进程通信，是早期UNIX系统最早使用的一种IPC机制
    2. 普通管道允许两个进程按标准的生产者—消费者方式进行通信，普通管道是单向的，只允许单向通信。如果需要双向，就要使用两个管道

14. #### 长期调度、中期调度和短期调度

    1. 长期调度（Long-term Scheduling）：
       - 功能：长期调度也被称为作业调度。它是在作业进入系统时进行的调度过程，决定是否将作业从作业队列中调入内存中执行。
       - 调度对象：调度的对象是作业（Job）或进程（Process）。
       - 目标：其目标是控制系统中的作业数量，以保持系统的吞吐量和资源利用率。
    2. 中期调度（Medium-term Scheduling）：
       - 功能：中期调度也被称为内存调度或交换调度。它是在内存中运行的进程过多时，将一部分进程从内存中调出，暂时存放到磁盘上，以提高系统的性能和吞吐量。
       - 调度对象：调度的对象是进程。
       - 目标：其目标是控制内存中的进程数量，以避免过度调度和资源竞争，提高系统的响应时间和吞吐量。
    3. 短期调度（Short-term Scheduling）：
       - 功能：短期调度也被称为CPU调度或进程调度。它是在内存中已经就绪的进程之间进行的调度过程，决定哪个进程将获得CPU的使用权。
       - 调度对象：调度的对象是进程。
       - 目标：其目标是提供公平的CPU时间分配，最大限度地减少等待时间，提高系统的响应速度和吞吐量。

### 4. 多线程编程

1. 线程是资源共享的，多个线程默认共享他们所属进程的内存和资源
2. 异步线程和同步线程。对于异步线程，一旦父线程创建了子线程后，父线程就恢复自身的执行，这样父线程会和自线程并发执行。而同步线程是父线程创建一个或多个子线程之后，子线程并发执行，但是父线程在子线程没有完成工作之前无法继续，会阻塞。只有所有子线程终止并于父线程连接之后，父线程恢复执行。通常同步线程涉及线程之间大量数据的共享。
3. 线程池： 线程池的思想是：在进程开始时创建一定数量的线程，并加到池中以等待工作。当服务器收到请求时，他会唤醒池内的一个可用线程，并将需要服务的请求传递给他。一旦线程完成了服务，他会返回到线程池中再等待工作唤醒。如果线程池中没有可用线程，那么服务器会等待，直到有可用线程为止
4. 传递信号的标准UNIX函数为kill(pid_t pid, int signal)，这个函数将一个特定信号传递到一个进程
5. 线程撤销：是在线程完成之前终止线程
6. Linux通过系统调用fork()提供进程赋值的功能，通过系统调用clone()提供创建线程的功能，但是Linux并不区分进程和线程，在讨论程序的控制流时，通常采用任务task一词来描述
7. 线程是进程内的控制流，是进程的一部分。线程间共享内存和其他资源



### 5. 进程调度

1. 非抢占(协作)调度和抢占调度：非抢占调度下，一旦某个进程分配到CPU，该进程就会一直使用CPU，直到他终止或切换到等待状态。

2. 调度程序是一个模块，用来将CPU控制交给由短期调度程序选择的进程。调度程序应尽可能快。调度程序停止一个进程而启动另一个进程的所需时间称为调度延迟

3. 轮转Round-Robin调度算法是专门为分时系统设计的

4. 多级队列调度：将就绪队列分成多个单独队列，根据进程属性，如优先级、进程类型等，分配不同队列，每个队列对应不同的调度算法。而不同队列之间也有调度，通常采用固定优先级抢占调度

5. 线程调度中一个重要概念：在支持线程的操作系统上，内核级线程（而不是进程）才是操作系统所调度的。用户级线程是由线程库来管理的，而内核并不知道他们。用户级线程为了运行在CPU上，最终应映射到相关的内核级线程，但是这种映射不是直接的，可能采用轻量级进程（LWP）。

6. 处理器核的多线程：粗粒度和细粒度的多线程。对于粗粒度的多线程，线程一直在处理器上执行，直到一个长延迟事件，如内存停顿发生。细粒度的多线程在更细的粒度上切换线程，比如在指令周期的边界上，这时候切换进程后冲刷CPU流水线带来的切换成本很小。

7. #### Linux内核中的线程调度算法：

   Linux内核中的线程调度算法主要是基于完全公平调度（CFS，Completely Fair Scheduler）。CFS是Linux 2.6内核引入的一种红黑树调度算法，旨在提供公平的CPU时间分配和高性能的多任务处理。

   CFS的主要特点和算法原理如下：

   1. 时间片分配：CFS不采用传统的固定时间片轮转调度算法，而是使用红黑树数据结构来维护任务队列。每个任务（进程或线程）都有一个虚拟运行时间（vruntime）来衡量其执行时间。任务的vruntime值越小，表示它已经消耗了更多的CPU时间，优先级较高。
   2. 公平性：CFS追求完全公平调度，即每个任务在一段时间内都能获得相同的CPU时间比例。通过计算任务的vruntime和实际消耗的CPU时间之间的差值，调度器决定下一个执行的任务。
   3. 动态优先级：CFS使用动态优先级来决定下一个要执行的任务。通过计算任务vruntime与系统当前时间的差值，可以确定任务的优先级。vruntime越小的任务，优先级越高。
   4. 实时任务支持：CFS还支持实时任务调度。实时任务通常具有较高的优先级和严格的时间限制。CFS通过与普通任务分开的红黑树来管理实时任务队列，并使用优先级划分来确保实时任务能够及时响应。

   CFS的设计目标是提供公平、高性能和低延迟的调度。它能够根据系统负载和任务需求进行动态调整，以适应不同的工作负载和系统环境。除了CFS，Linux内核中还有其他调度算法，如实时调度器（SCHED_FIFO、SCHED_RR）和实时公平调度器（SCHED_DEADLINE），用于特定的调度需求和场景。



### 6. 同步

1. 临界区问题，互斥的解决，硬件的原子指令

2. 抢占式内核与非抢占式内核

3. #### 互斥锁

   1. 自旋锁: spinlock,将一直循环等待临界区的锁被释放，适用于对临界区数据处理较快的情况，这样不会造成CPU的浪费

4. #### 信号量semaphore

   1. 除了初始化外只能使用两个原子操作指令，wait()和signal()会包含这两个原子指令，分别是立增和立减
   2. 信号量分为二值信号量和计数信号量。计数信号量类似与RTT中的sema，而二进制信号量就类似mutex
   3. 如果执行wait()之后无法得到信号量，则会阻塞自己，把自己放到与信号量相关的等待队列中，并且将该进程的状态切换为等待状态，等到signal()被执行后通过wakeup()再唤醒这个进程。与RTT中的处理是一样的
   4. 
   5. 

5. 需要指出的一点是，在但处理器中，可以简单使用关中断的方法来实现互斥操作，就像在RTT中实现的那样，在mq,mailbox,mutex,sema等操作中，首先的处理步骤就是关中断，然后在来处理互斥量，之后再开中断

6. #### 死锁

   1. 多个进程无限等待一个事件，而这个事件又只能由等待的进程来实现，这样的状态就成为死锁
   2. 优先级反转问题，高优先级进程等待低优先级释放锁。

7. #### 经典同步问题

   1. 有界缓冲问题： 即资源数不是二值的，而是多个，类似RTT中的sema和mailbox
   2. 读者-作者问题：即对于临界区数据的只读模式，可以支持多个进程并发访问，这可以认为是读者模式；而对于作者来说，当他在写时，不应该有其他进程访问临界区。因此我们可以同时维护两把锁，一把锁分配给读者，他们可以同时并发访问，而另一把分配给作者，他必须是互斥的
   3. 哲学家就餐问题：是描述多个进程访问多个资源的典型例子。操作系统应该确保在处理这类模型时候，不会让进程出现死锁或者饥饿的状态。死锁的问题有很多补救措施，比如要求哲学家只有同时能获取到两只筷子时才能拿起筷子，或者单号拿左边的筷子等。但是在解决方案上，有可能解决死锁的方案并不一定能保证进程不会出现饥饿。