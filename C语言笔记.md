### C Notes!



### 一.编译过程！

1. #### 预处理—— .i文件

   1. 预处理阶段只进行文本粘贴，不求值
   2. 去掉注释
   3. 连接因断行符(行尾的`\`)而拆分的字符串
   4. 处理条件编译 `#ifdef`/`#else`/`#endif`
   5. 字符串化 `#` 。#就是能把参数变成字符串。如：#abcd -> “abcd”
   6. 标识符连接 `##`  而##就是连接，如a##b##c  -> abc

2. #### 编译——.s文件

   1. 词法分析 -> 语法分析 -> 语义分析 -> 中间代码生成 -> 优化 -> 目标代码生成
   2. 主要是编译源代码生成汇编指令

3. #### 汇编——.o文件

   1. 将.s文件转换为2进制的机器指令，生成对象文件

4. #### 链接——可执行文件，linux下是elf格式

   1. 合并多个目标文件，生成可执行文件



### 二.链接（静态&动态）

1. ELF文件中一些常见的节![image-20230729170617506](/home/jixiang/.config/Typora/typora-user-images/image-20230729170617506.png)

2. ELF文件格式![image-20230729170942225](/home/jixiang/.config/Typora/typora-user-images/image-20230729170942225.png)

3. 编译/汇编都无法解决的问题: 跨节的函数和数据引用。编译和汇编都是以文件为单位进行的，标记为*的指令/数据无法得知最终地址
4. 链接的本质工作：
   1. 符号解析—处理符号的引用：将符号的引用与符号的定义建立关联
   2. 重定位(relocation) - 合并相同的节：确定每一个符号的最终地址, 并填写到引用处
5. 符号表：使用readelf  -s参数来查看目标文件中的符号表![image-20230729171608336](/home/jixiang/.config/Typora/typora-user-images/image-20230729171608336.png)

6. 静态库链接
   1. 将每个库函数的.o打包成一个.a文件, 用户只需要指定这个.a文件，链接器在符号解析时按需取出用到的.o文件, 没有用到的.o文件不参与链接
   2. 使用ar工具可以打包.o文件生成静态链接库.a文件
7. 动态链接
   1. 有别于静态链接，他在可执行程序需要调用到库函数的位置做了标记，当可执行程序运行到调用该库函数的位置，会自动将该动态库加载到内存，以后不管多少个应用程序同时运行，该库函数在内存中只有一份
   2. 使用-shared参数生成.so动态库
8. 总结：链接 = 符号解析 + 重定位



### 三.数据类型

1. register存储类：用于定义存储在寄存器中而不是 RAM 中的局部变量。所以变量的访问速度更快，但是它不能直接取地址。例如：register int miles;
2. static：
   1. 指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。
   2. static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
3. extern：定义在其他文件中声明的全局变量或函数。当使用 extern 关键字时，不会为变量分配任何存储空间，而只是指示编译器该变量在其他文件中定义。

4. 函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用
5. 全局变量与局部变量在内存中的区别：
   1. 全局变量保存在内存的全局存储区中，占用静态的存储单元；
   2. 局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。
6. 回调函数：本质上其实就是一个通过函数指针调用的函数！
7. typedef于#define：
   1. typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。
   2. typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。
8. 