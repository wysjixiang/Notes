---

---

# 				学习笔记



### 文件IO

1. 用户陷入异常进入内核态，他的参数传递等规范是由ABI来规范的。ABI： Application Binary Interface，应用程序二进制接口。比如riscv架构，就是通过a7寄存器来识别是哪种异常的！
2. 

### 底层库函数

1. mmap：用于映射内存空间的，比如把VGA显存的地址空间映射到一个指定的buf
2.  

### 输入输出系统、





### 网络通信

1. 所有的数据传输，都有三个要素： 源、目的、长度。 在网络传输中使用IP和端口表示源和目的
2. 2个对象： server和client
3. 2种传输方式： TCP和UDP
4. 



### linux内核驱动

1. `class_create` 函数用于创建一个设备类（`struct class` 结构体）。设备类是一个用于管理设备的抽象概念，它将相关的设备进行分组，并提供一些通用的操作函数和属性。通过设备类，可以方便地对设备进行管理和操作。

   具体作用包括：

   - 创建一个设备类，包括设备类的名称、父设备类、设备类的属性等信息。
   - 创建设备类的 sysfs 目录，用于在用户空间中显示设备信息。
   - 自动创建设备类的设备目录 `/sys/class/<class_name>`。

2. `device_create` 函数用于创建一个设备（`struct device` 结构体）。设备是设备驱动程序与实际硬件设备之间的接口，它代表了实际的设备并提供了设备操作的接口函数。

   具体作用包括：

   - 在指定的设备类下创建一个设备。
   - 设置设备的相关属性，如设备名称、设备号等。
   - 自动创建设备的设备文件节点 `/dev/<device_name>`。

3. `register_chrdev` 函数是 Linux 内核提供的用于注册字符设备驱动的函数。

   该函数用于向内核注册一个字符设备驱动，并返回注册成功后分配的主设备号。参数说明如下：

   - `major`：指定要注册的字符设备驱动的主设备号。如果传入 0，则表示由内核自动分配主设备号。
   - `name`：指定字符设备驱动的名称。该名称将在 `/proc/devices` 中显示。
   - `fops`：指定字符设备驱动的操作函数集合，即 `struct file_operations` 结构体的指针。操作函数集合中包含了设备的打开、关闭、读写等操作函数。

   函数执行成功时，返回分配的主设备号；执行失败时，返回负值错误码。

   使用 `register_chrdev` 函数注册字符设备驱动后，可以通过 `mknod` 命令创建设备文件节点，并使用打开、读写等系统调用进行对设备的操作。

   需要注意的是，Linux 内核 2.6.x 版本引入了新的字符设备注册机制，即 `register_chrdev_region` 和 `alloc_chrdev_region` 函数，用于替代 `register_chrdev` 函数。这些函数提供了更灵活的主设备号分配方式，具体使用方法可以参考相关文档和示例代码。

4. 注意platfrom_driver和platform_device的匹配过程，他们是如何匹配的？非常需要注意platform_driver中的.driver.name属性，尽管他的匹配优先级在of_match_table之后，但是他不能为NULL！因为driver_find函数会使用他来做strcmp！



### 异常与中断

1. 硬件中断不可以被嵌套，软件中断可以。
2. 中断可以分为中断上半部和下半部，上半部是硬件中断，下半部是软件中断，处理时会把中断开关打开，并且在下半部处理过程中，是处理所有的tasklet软件中断！但有一个问题是他是在中断程序中执行的，这个期间APP是无法相应的。
3. 当中断下半部耗时严重时候，可以创建内核线程来处理-work 内核线程 — work queue队列，就是工作队列
4. 还可以改进，线程化的中断。对每一个中断都创建一个内核线程，这样可以分配给多个核来处理
5. 中断控制器已经都由厂家的BSP工程师写好，用户只需要指定设备的中断即可
6. 



### 驱动程序基石

#### 1.休眠与唤醒

1. 理解队列
2. wait_event_interruptible(wq, condition)，休眠，直到condition为真

#### 2. POLL机制

1. 在休眠基础上，增加时间限制，这就是poll机制
2. POLL会在定时时间达到时再次检查条件是否满足，因此POLL有可能会检查两次条件！
3. 注意poll这些都是系统调用，因此休眠的其实是内核的线程
4. 涉及数据读写时，存在内核态和用户态的数据拷贝
5. 

